{"meta":{"title":"施工中","subtitle":"记录生活","description":"","author":"DDDivano","url":"http://www.zhengtianyu.com","root":"/"},"pages":[{"title":"about me","date":"2021-08-18T07:56:56.000Z","updated":"2021-08-18T08:00:18.097Z","comments":true,"path":"about/index.html","permalink":"http://www.zhengtianyu.com/about/index.html","excerpt":"","text":"互联网民工。非专业摄影师。"},{"title":"标签","date":"2021-08-17T09:16:29.000Z","updated":"2021-08-17T10:25:32.729Z","comments":true,"path":"tags/index.html","permalink":"http://www.zhengtianyu.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-17T09:16:04.000Z","updated":"2021-08-17T10:25:27.814Z","comments":true,"path":"categories/index.html","permalink":"http://www.zhengtianyu.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"pyautogui鼠标操作","slug":"pyautogui鼠标操作","date":"2021-10-09T02:27:03.000Z","updated":"2021-10-09T03:27:43.752Z","comments":true,"path":"2021/10/09/pyautogui鼠标操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/10/09/pyautogui%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/","excerpt":"鼠标控制功能 PyAutoGUI lets your Python scripts control the mouse and keyboard to automate interactions with other applications. The API is designed to be simple. PyAutoGUI works on Windows, macOS, and Linux, and runs on Python 2 and 3.","text":"鼠标控制功能 PyAutoGUI lets your Python scripts control the mouse and keyboard to automate interactions with other applications. The API is designed to be simple. PyAutoGUI works on Windows, macOS, and Linux, and runs on Python 2 and 3. 屏幕和鼠标尺寸位置屏幕上的位置是通过X,Y坐标来确定的。和传统数学坐标系不同，X从左往右依次增大，Y从上往下依次增大。 123456789100,0 X increases --&gt;+---------------------------+| | Y increases| | || 1920 x 1080 screen | || | V| || |+---------------------------+ 1919, 1079 最左上角的屏幕像素被标记为（0，0）。如果你的屏幕是1920 * 1080， 那么右下角的像素会被标记为（1919，1079），因为像素是从0开始算不是1。屏幕分辨率大小由函数size()返回，鼠标的位置由函数position()返回 12345&gt;&gt;&gt; pyautogui.size()(1920, 1080)&gt;&gt;&gt; pyautogui.position()(187, 567) 下面是一个py3小程序，它将不断的打印光标的位置 1234567891011#! python3import pyautogui, sysprint(&#x27;Press Ctrl-C to quit.&#x27;)try: while True: x, y = pyautogui.position() positionStr = &#x27;X: &#x27; + str(x).rjust(4) + &#x27; Y: &#x27; + str(y).rjust(4) print(positionStr, end=&#x27;&#x27;) print(&#x27;\\b&#x27; * len(positionStr), end=&#x27;&#x27;, flush=True)except KeyboardInterrupt: print(&#x27;\\n&#x27;) 为了检测某个X，Y坐标是不是在屏幕范围内，可以通过list or tuple传入onScreen()函数来判断，如果在屏幕上，返回True，否则，返回False。 123456789101112&gt;&gt;&gt; pyautogui.onScreen(0, 0)True&gt;&gt;&gt; pyautogui.onScreen(0, -1)False&gt;&gt;&gt; pyautogui.onScreen(0, 99999999)False&gt;&gt;&gt; pyautogui.size()(1920, 1080)&gt;&gt;&gt; pyautogui.onScreen(1920, 1080)False&gt;&gt;&gt; pyautogui.onScreen(1919, 1079)True 鼠标移动功能moveTo()函数用来将鼠标指针移动到指定的(X,Y)坐标。None可以作为参数传入表示当前鼠标的对应位置坐标不变。 123&gt;&gt;&gt; pyautogui.moveTo(100, 200) # moves mouse to X of 100, Y of 200.&gt;&gt;&gt; pyautogui.moveTo(None, 500) # moves mouse to X of 100, Y of 500.&gt;&gt;&gt; pyautogui.moveTo(600, None) # moves mouse to X of 600, Y of 500. 通常鼠标会立即移动到指定的位置，如果你想让它逐渐的移动到某一个位置，可以传入第三个参数。 1&gt;&gt;&gt; pyautogui.moveTo(100, 200, 2) # moves mouse to X of 100, Y of 200 over 2 seconds (If the duration is less than pyautogui.MINIMUM_DURATION the movement will be instant. By default, pyautogui.MINIMUM_DURATION is 0.1.)上面意思是如果你设置小于 或值，嗯，那他就不生效 如果你想移动相对位置，可以使用move()函数 1234&gt;&gt;&gt; pyautogui.moveTo(100, 200) # moves mouse to X of 100, Y of 200.&gt;&gt;&gt; pyautogui.move(0, 50) # move the mouse down 50 pixels.&gt;&gt;&gt; pyautogui.move(-30, 0) # move the mouse left 30 pixels.&gt;&gt;&gt; pyautogui.move(-30, None) # move the mouse left 30 pixels. 鼠标拖拽功能鼠标拖拽和鼠标移动类似，无非就是加了一个按键参数，通过哪个按键拖拽left,middle,right。通过dragTo(), drag()完成操作。 123&gt;&gt;&gt; pyautogui.dragTo(100, 200, button=&#x27;left&#x27;) # drag mouse to X of 100, Y of 200 while holding down left mouse button&gt;&gt;&gt; pyautogui.dragTo(300, 400, 2, button=&#x27;left&#x27;) # drag mouse to X of 300, Y of 400 over 2 seconds while holding down left mouse button&gt;&gt;&gt; pyautogui.drag(30, 0, 2, button=&#x27;right&#x27;) # drag the mouse left 30 pixels over 2 seconds while holding down the right mouse button Tween / Easing Functions这段懒得翻译因为的确没啥大用Tweening is an extra feature to make the mouse movements fancy. You can probably skip this section if you don’t care about this. A tween or easing function dictates the progress of the mouse as it moves to its destination. Normally when moving the mouse over a duration of time, the mouse moves directly towards the destination in a straight line at a constant speed. This is known as a linear tween or linear easing function. PyAutoGUI has other tweening functions available in the pyautogui module. The pyautogui.easeInQuad function can be passed for the 4th argument to moveTo(), move(), dragTo(), and drag() functions to have the mouse cursor start off moving slowly and then speeding up towards the destination. The total duration is still the same as the argument passed to the function. The pyautogui.easeOutQuad is the reverse: the mouse cursor starts moving fast but slows down as it approaches the destination. The pyautogui.easeOutElastic will overshoot the destination and “rubber band” back and forth until it settles at the destination. For example: 12345&gt;&gt;&gt; pyautogui.moveTo(100, 100, 2, pyautogui.easeInQuad) # start slow, end fast&gt;&gt;&gt; pyautogui.moveTo(100, 100, 2, pyautogui.easeOutQuad) # start fast, end slow&gt;&gt;&gt; pyautogui.moveTo(100, 100, 2, pyautogui.easeInOutQuad) # start and end fast, slow in middle&gt;&gt;&gt; pyautogui.moveTo(100, 100, 2, pyautogui.easeInBounce) # bounce at the end&gt;&gt;&gt; pyautogui.moveTo(100, 100, 2, pyautogui.easeInElastic) # rubber band at the end These tweening functions are copied from Al Sweigart’s PyTweening module: https://pypi.python.org/pypi/PyTweening https://github.com/asweigart/pytweening This module does not have to be installed to use the tweening functions. If you want to create your own tweening function, define a function that takes a single float argument between 0.0 (representing the start of the mouse travelling) and 1.0 (representing the end of the mouse travelling) and returns a float value between 0.0 and 1.0. 鼠标点击操作click()函数模拟一次在当前位置鼠标左键的点击操作。点击操作的定义是按下鼠标按键然后抬起。 12&gt;&gt;&gt; pyautogui.click() # click the mouse 结合了moveTo()功能，可以传入点击的坐标。 1&gt;&gt;&gt; pyautogui.click(x=100, y=200) # move to 100, 200, then click the left mouse button. 可以指定用哪个按键点击left,middle,right 1&gt;&gt;&gt; pyautogui.click(button=&#x27;right&#x27;) # right-click the mouse 为了做多次点击操作，可以传入clicks参数，并且，你可以通过interval参数来设定每次点击之间的间隔时间。 1234&gt;&gt;&gt; pyautogui.click(clicks=2) # double-click the left mouse button&gt;&gt;&gt; pyautogui.click(clicks=2, interval=0.25) # double-click the left mouse button, but with a quarter second pause in between clicks&gt;&gt;&gt; pyautogui.click(button=&#x27;right&#x27;, clicks=3, interval=0.25) ## triple-click the right mouse button with a quarter second pause in between clicks As a convenient shortcut, the doubleClick() function will perform a double click of the left mouse button. It also has the optional x, y, interval, and button keyword arguments. For example: 1&gt;&gt;&gt; pyautogui.doubleClick() # perform a left-button double click There is also a tripleClick() function with similar optional keyword arguments. The rightClick() function has optional x and y keyword arguments. 鼠标按下和抬起功能可以通过mouseDown() mouseUp()来定义鼠标按下和抬起操作，实现拖拽功能 123&gt;&gt;&gt; pyautogui.mouseDown(); pyautogui.mouseUp() # does the same thing as a left-button mouse click&gt;&gt;&gt; pyautogui.mouseDown(button=&#x27;right&#x27;) # press the right button down&gt;&gt;&gt; pyautogui.mouseUp(button=&#x27;right&#x27;, x=100, y=200) # move the mouse to 100, 200, then release the right button up. 鼠标滚动The mouse scroll wheel can be simulated by calling the scroll() function and passing an integer number of “clicks” to scroll. The amount of scrolling in a “click” varies between platforms. Optionally, integers can be passed for the the x and y keyword arguments to move the mouse cursor before performing the scroll. For example: 123&gt;&gt;&gt; pyautogui.scroll(10) # scroll up 10 &quot;clicks&quot;&gt;&gt;&gt; pyautogui.scroll(-10) # scroll down 10 &quot;clicks&quot;&gt;&gt;&gt; pyautogui.scroll(10, x=100, y=100) # move mouse cursor to 100, 200, then scroll up 10 &quot;clicks&quot; On OS X and Linux platforms, PyAutoGUI can also perform horizontal scrolling by calling the hscroll() function. For example: 12&gt;&gt;&gt; pyautogui.hscroll(10) # scroll right 10 &quot;clicks&quot;&gt;&gt;&gt; pyautogui.hscroll(-10) # scroll left 10 &quot;clicks&quot; The scroll() function is a wrapper for vscroll(), which performs vertical scrolling.","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"编程技术/python","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/python/"}],"tags":[{"name":"界面辅助","slug":"界面辅助","permalink":"http://www.zhengtianyu.com/tags/%E7%95%8C%E9%9D%A2%E8%BE%85%E5%8A%A9/"},{"name":"自动化","slug":"自动化","permalink":"http://www.zhengtianyu.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"pyautogui","slug":"pyautogui","permalink":"http://www.zhengtianyu.com/tags/pyautogui/"}]},{"title":"pyautogui截屏操作","slug":"pyautogui截屏操作","date":"2021-09-28T03:12:50.000Z","updated":"2021-10-09T03:30:23.977Z","comments":true,"path":"2021/09/28/pyautogui截屏操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/09/28/pyautogui%E6%88%AA%E5%B1%8F%E6%93%8D%E4%BD%9C/","excerpt":"title details","text":"title details","categories":[],"tags":[]},{"title":"pyautogui弹窗操作","slug":"pyautogui弹窗操作","date":"2021-09-28T03:12:37.000Z","updated":"2021-10-09T03:30:21.313Z","comments":true,"path":"2021/09/28/pyautogui弹窗操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/09/28/pyautogui%E5%BC%B9%E7%AA%97%E6%93%8D%E4%BD%9C/","excerpt":"title details","text":"title details","categories":[],"tags":[]},{"title":"pyautogui键盘操作","slug":"pyautogui键盘操作","date":"2021-09-28T03:12:09.000Z","updated":"2021-10-09T03:30:27.083Z","comments":true,"path":"2021/09/28/pyautogui键盘操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/09/28/pyautogui%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C/","excerpt":"title details","text":"title details","categories":[],"tags":[]},{"title":"pyautogui学习","slug":"pyautogui学习","date":"2021-09-27T03:07:06.000Z","updated":"2021-09-28T03:11:01.532Z","comments":true,"path":"2021/09/27/pyautogui学习/","link":"","permalink":"http://www.zhengtianyu.com/2021/09/27/pyautogui%E5%AD%A6%E4%B9%A0/","excerpt":"pyautogui学习 PyAutoGUI lets your Python scripts control the mouse and keyboard to automate interactions with other applications. The API is designed to be simple. PyAutoGUI works on Windows, macOS, and Linux, and runs on Python 2 and 3.","text":"pyautogui学习 PyAutoGUI lets your Python scripts control the mouse and keyboard to automate interactions with other applications. The API is designed to be simple. PyAutoGUI works on Windows, macOS, and Linux, and runs on Python 2 and 3. 整理于：https://pyautogui.readthedocs.io/en/latest/index.html 基础pyautogui能做什么 在窗口应用中移动鼠标，点击鼠标 在窗口应用中发送键盘指令 截图，通过图片寻找在截图中匹配的坐标（简单的图像匹配） 定位一个应用窗口，移动，缩放，最大化，最小化，关闭（只支持win） 显示警告和信息窗口 入门案例123456789101112131415161718192021222324252627282930import pyautogui&gt;&gt;&gt; screenWidth, screenHeight = pyautogui.size() # Get the size of the primary monitor.&gt;&gt;&gt; screenWidth, screenHeight(2560, 1440)&gt;&gt;&gt; currentMouseX, currentMouseY = pyautogui.position() # Get the XY position of the mouse.&gt;&gt;&gt; currentMouseX, currentMouseY(1314, 345)&gt;&gt;&gt; pyautogui.moveTo(100, 150) # Move the mouse to XY coordinates.&gt;&gt;&gt; pyautogui.click() # Click the mouse.&gt;&gt;&gt; pyautogui.click(100, 200) # Move the mouse to XY coordinates and click it.&gt;&gt;&gt; pyautogui.click(&#x27;button.png&#x27;) # Find where button.png appears on the screen and click it.&gt;&gt;&gt; pyautogui.move(400, 0) # Move the mouse 400 pixels to the right of its current position.&gt;&gt;&gt; pyautogui.doubleClick() # Double click the mouse.&gt;&gt;&gt; pyautogui.moveTo(500, 500, duration=2, tween=pyautogui.easeInOutQuad) # Use tweening/easing function to move mouse over 2 seconds.&gt;&gt;&gt; pyautogui.write(&#x27;Hello world!&#x27;, interval=0.25) # type with quarter-second pause in between each key&gt;&gt;&gt; pyautogui.press(&#x27;esc&#x27;) # Press the Esc key. All key names are in pyautogui.KEY_NAMES&gt;&gt;&gt; with pyautogui.hold(&#x27;shift&#x27;): # Press the Shift key down and hold it. pyautogui.press([&#x27;left&#x27;, &#x27;left&#x27;, &#x27;left&#x27;, &#x27;left&#x27;]) # Press the left arrow key 4 times.&gt;&gt;&gt; # Shift key is released automatically.&gt;&gt;&gt; pyautogui.hotkey(&#x27;ctrl&#x27;, &#x27;c&#x27;) # Press the Ctrl-C hotkey combination.&gt;&gt;&gt; pyautogui.alert(&#x27;This is the message to display.&#x27;) # Make an alert box appear and pause the program until OK is clicked. 安全控制由于pyautogui是会操控鼠标和键盘，所以一旦你的程序出现了失控场景，你很难通过鼠标关闭程序。程序会默认pyautogui.FAILSAFE = True来抛出一个pyautogui.FailSafeException异常终止程序运行。由于每次执行pyautogui函数后都会有一个gap时间，你可以利用这个gap触发异常终止程序运行。当然，你也可以关闭FAILSAFE但是我墙裂建议不要这么做。 基本用法表安装1pip install pyautogui 导入1import pyautogui as pag 安全控制1234567# 语句执行时间间隔&gt;&gt;&gt; import pyautogui&gt;&gt;&gt; pyautogui.PAUSE = 2.5# 安全开启参数&gt;&gt;&gt; import pyautogui&gt;&gt;&gt; pyautogui.FAILSAFE = True 鼠标功能x，y坐标从屏幕左上角开始算（0，0），x增加表现为右移，y增加表现为下移。 12&gt;&gt;&gt; pyautogui.moveTo(x, y, duration=num_seconds) # move mouse to XY coordinates over num_second seconds&gt;&gt;&gt; pyautogui.moveRel(xOffset, yOffset, duration=num_seconds) # move mouse relative to its current position If duration is 0 or unspecified, movement is immediate. Note: dragging on Mac can’t be immediate.如果duration参数为0或者未给出，移动是瞬间完成。但是mac上拖动操作不能瞬间完成 12&gt;&gt;&gt; pyautogui.dragTo(x, y, duration=num_seconds) # drag mouse to XY&gt;&gt;&gt; pyautogui.dragRel(xOffset, yOffset, duration=num_seconds) # drag mouse relative to its current position Calling click() just clicks the mouse once with the left button at the mouse’s current location, but the keyword arguments can change that:调用click()函数作用是在当前位置点击一次鼠标左键，但是keyword参数可以更改这个行为 1&gt;&gt;&gt; pyautogui.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button=&#x27;left&#x27;) The button keyword argument can be ‘left’, ‘middle’, or ‘right’.button参数可选值有left,middle,right All clicks can be done with click(), but these functions exist for readability. Keyword args are optional:全部点击操作都可以用click()实现，但是这些函数存在并且更加已读。 1234&gt;&gt;&gt; pyautogui.rightClick(x=moveToX, y=moveToY)&gt;&gt;&gt; pyautogui.middleClick(x=moveToX, y=moveToY)&gt;&gt;&gt; pyautogui.doubleClick(x=moveToX, y=moveToY)&gt;&gt;&gt; pyautogui.tripleClick(x=moveToX, y=moveToY) Positive scrolling will scroll up, negative scrolling will scroll down:正向滚动向上，反向滚动向下 1&gt;&gt;&gt; pyautogui.scroll(amount_to_scroll, x=moveToX, y=moveToY) Individual button down and up events can be called separately:鼠标按下和抬起事件可以单独调用 12&gt;&gt;&gt; pyautogui.mouseDown(x=moveToX, y=moveToY, button=&#x27;left&#x27;)&gt;&gt;&gt; pyautogui.mouseUp(x=moveToX, y=moveToY, button=&#x27;left&#x27;) 键盘功能Key presses go to wherever the keyboard cursor is at function-calling time.按键时光标在哪，就在哪里执行命令 1&gt;&gt;&gt; pyautogui.typewrite(&#x27;Hello world!\\n&#x27;, interval=secs_between_keys) # useful for entering text, newline is Enter A list of key names can be passed too:按键序列也可以使用 1&gt;&gt;&gt; pyautogui.typewrite([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;left&#x27;, &#x27;backspace&#x27;, &#x27;enter&#x27;, &#x27;f1&#x27;], interval=secs_between_keys) The full list of key names is in pyautogui.KEYBOARD_KEYS全部是按键名称列表在pyautogui.KEYBOARD_KEYS Keyboard hotkeys like Ctrl-S or Ctrl-Shift-1 can be done by passing a list of key names to hotkey():键盘热键例如Ctrl-S or Ctrl-Shift-1可以通过传入一系列按键名称，通过hotkey()函数实现 12&gt;&gt;&gt; pyautogui.hotkey(&#x27;ctrl&#x27;, &#x27;c&#x27;) # ctrl-c to copy&gt;&gt;&gt; pyautogui.hotkey(&#x27;ctrl&#x27;, &#x27;v&#x27;) # ctrl-v to paste Individual button down and up events can be called separately:键盘按下和抬起事件可以单独调用 12&gt;&gt;&gt; pyautogui.keyDown(key_name)&gt;&gt;&gt; pyautogui.keyUp(key_name) 信息提示弹窗If you need to pause the program until the user clicks OK on something, or want to display some information to the user, the message box functions have similar names that JavaScript has:如果你需要暂停程序直到用户点击ok，或者显示给用户一些信息，信息框可以实现 12345678# 警告框&gt;&gt;&gt; pyautogui.alert(&#x27;This displays some text with an OK button.&#x27;)# 确认取消框&gt;&gt;&gt; pyautogui.confirm(&#x27;This displays text and has an OK and Cancel button.&#x27;)&#x27;OK&#x27;# 带输入框弹窗&gt;&gt;&gt; pyautogui.prompt(&#x27;This lets the user type in a string and press OK.&#x27;)&#x27;This is what I typed in.&#x27; The prompt() function will return None if the user clicked Cancel.如果点击cancel，prompt()会返回None 截图操作PyAutoGUI uses Pillow/PIL for its image-related data.On Linux, you must run sudo apt-get install scrot to use the screenshot features. 1234&gt;&gt;&gt; pyautogui.screenshot() # returns a Pillow/PIL Image object&lt;PIL.Image.Image image mode=RGB size=1920x1080 at 0x24C3EF0&gt;&gt;&gt;&gt; pyautogui.screenshot(&#x27;foo.png&#x27;) # returns a Pillow/PIL Image object, and saves it to a file&lt;PIL.Image.Image image mode=RGB size=1920x1080 at 0x31AA198&gt; If you have an image file of something you want to click on, you can find it on the screen with locateOnScreen().如果你有一张图片文件或者其他什么东西想点击的，你可以通过locateOnScreen()函数在屏幕上找到它们。 12&gt;&gt;&gt; pyautogui.locateOnScreen(&#x27;looksLikeThis.png&#x27;) # returns (left, top, width, height) of first place it is found(863, 417, 70, 13) The locateAllOnScreen() function will return a generator for all the locations it is found on the screen:函数locateAllOnScreen()会返回一个生成器，其中包含了所有坐标 123456789101112&gt;&gt;&gt; for i in pyautogui.locateAllOnScreen(&#x27;looksLikeThis.png&#x27;)......(863, 117, 70, 13)(623, 137, 70, 13)(853, 577, 70, 13)(883, 617, 70, 13)(973, 657, 70, 13)(933, 877, 70, 13)&gt;&gt;&gt; list(pyautogui.locateAllOnScreen(&#x27;looksLikeThis.png&#x27;))[(863, 117, 70, 13), (623, 137, 70, 13), (853, 577, 70, 13), (883, 617, 70, 13), (973, 657, 70, 13), (933, 877, 70, 13)] The locateCenterOnScreen() function just returns the XY coordinates of the middle of where the image is found on the screen:函数locateCenterOnScreen() 只返回找到图像的中间坐标 12&gt;&gt;&gt; pyautogui.locateCenterOnScreen(&#x27;looksLikeThis.png&#x27;) # returns center x and y(898, 423) These functions return None if the image couldn’t be found on the screen. Note: The locate functions are slow and can take a full second or two.注意：这玩意执行很慢","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"编程技术/python","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/python/"}],"tags":[{"name":"界面辅助","slug":"界面辅助","permalink":"http://www.zhengtianyu.com/tags/%E7%95%8C%E9%9D%A2%E8%BE%85%E5%8A%A9/"},{"name":"自动化","slug":"自动化","permalink":"http://www.zhengtianyu.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"pyautogui","slug":"pyautogui","permalink":"http://www.zhengtianyu.com/tags/pyautogui/"}]},{"title":"阴阳师御魂整理","slug":"阴阳师御魂整理","date":"2021-08-22T12:49:34.000Z","updated":"2021-08-23T07:23:32.650Z","comments":true,"path":"2021/08/22/阴阳师御魂整理/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/22/%E9%98%B4%E9%98%B3%E5%B8%88%E5%BE%A1%E9%AD%82%E6%95%B4%E7%90%86/","excerpt":"阴阳师御魂整理 主要记录御魂相关内容","text":"阴阳师御魂整理 主要记录御魂相关内容 御魂时间轮换表 御魂主属性数值参考 御魂副属性数值参考 御魂整理方案御魂整理方案","categories":[{"name":"游戏人生","slug":"游戏人生","permalink":"http://www.zhengtianyu.com/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"},{"name":"阴阳师","slug":"游戏人生/阴阳师","permalink":"http://www.zhengtianyu.com/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/%E9%98%B4%E9%98%B3%E5%B8%88/"}],"tags":[]},{"title":"阴阳师必备游戏手册","slug":"阴阳师必备游戏手册","date":"2021-08-22T07:09:15.000Z","updated":"2021-08-22T13:23:57.812Z","comments":true,"path":"2021/08/22/阴阳师必备游戏手册/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/22/%E9%98%B4%E9%98%B3%E5%B8%88%E5%BF%85%E5%A4%87%E6%B8%B8%E6%88%8F%E6%89%8B%E5%86%8C/","excerpt":"阴阳师必备游戏手册 主要记录日常，周常，怪物，资源获取等内容","text":"阴阳师必备游戏手册 主要记录日常，周常，怪物，资源获取等内容 悬赏任务怪物分布 日常打卡 地域鬼王 免费一抽 （必须签到500天） 喂猫喂狗 寮30 商店黑蛋 大神登录 每日任务 寮碎片祈愿，赠予 结界卡，蹭卡以上尽量都做 以下选做10. 式神委派11. 50协战12. 金币大作战13. 石距，年兽 周常打卡 图鉴分享 鬼王分享 竞速本 寮功勋 勋章商店 友情白蛋 荣誉商店 蛇皮商店 每日活动 寮突破 结界突破 逢魔 道馆 狩猎战 式神升星养成攻略准备狗粮方式123456782-&gt;3全部的N卡2星升满级，吃红蛋变3星。3-&gt;43星白蛋吃三星n卡到4星。4-&gt;54星满级白蛋吃刚到4星白蛋升至5星白蛋。5-&gt;65个5星白蛋给五星式神到6 二星到三星养成式神到20级，吃2个2星N卡红蛋。 2w金 三星升级四星式神25级， 吃3个3星N卡红蛋，3w金 四星升级五星式神30级， 吃4个4星白蛋，4w金 五星升级六星式神35级，吃5个5星白蛋，5w金 总计：一个式神从2星升级到6星狗粮需要：5个5星白蛋+20个4星白蛋+60个3星N卡+120个红蛋or2星n卡5星式神需要：4个4星白蛋+12个3星N卡+24个红蛋or2星n卡共需要：29个高星白蛋+216个N卡 如果白蛋都是从2级升上来，这个不再额外计算。 附录经验获取表 经验需求表","categories":[{"name":"游戏人生","slug":"游戏人生","permalink":"http://www.zhengtianyu.com/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"},{"name":"阴阳师","slug":"游戏人生/阴阳师","permalink":"http://www.zhengtianyu.com/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/%E9%98%B4%E9%98%B3%E5%B8%88/"}],"tags":[]},{"title":"深度学习框架入门","slug":"深度学习框架入门","date":"2021-08-20T10:38:59.000Z","updated":"2021-08-27T08:39:40.738Z","comments":true,"path":"2021/08/20/深度学习框架入门/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/","excerpt":"深度学习框架入门 本篇文章介绍深度学习框架基础知识，并手动实现基础逻辑。","text":"深度学习框架入门 本篇文章介绍深度学习框架基础知识，并手动实现基础逻辑。 深度学习框架是什么深度学习框架就是一套用于深度学习的函数。在深度学习中，有这样几种基本操作：卷积，池化，全连接，二分类多分类，反向传播等。好处是你不必重复造轮子，模型也就是积木，是给你的，你可以直接组装。 用深度学习框架构建模型大概可以分成以下几部分： 当然，你用深度学习框架，实现这几部分的功能后，就可以正常的去跑一个模型训练，就实现了模型训练的基本功能。但是框架能够实现的远远不止这些，比如额外的有，分布式相关的管理控制，内存显存优化，模型存储，丰富的打印函数，调试工具，部署工具和部署库。但是这些都是基于深度学习衍生出来的工程向的内容，那么对于深度学习本身来说，最重要的功能，一是丰富的算子库，二是自动求导。这可以极大的减少我们的工作量。 深度学习运行机制深度学习框架看着很庞大，其实实现核心内容，是一个非常直观且容易的事情。我们知道，深度学习梯度计算就是使用了链式法则，这个反向计算是深度学习框架的一大重要组成部分。对于一个模型来说，前向和反向的迭代计算占据了一个模型90%的工作量。我们只需要按照上一小节，实现相关模块，便可以手动写一个深度学习训练出来。 实际上除了要实现的计算层之外，深度学习本质就是一个前向和反向的过程。对于前向，我们可以使用numpy进行计算得到，事实上numpy几乎可以实现现有90%以上深度学习网络的过程。对于反向，需要我们自己来实现相关代码，即求导过程。对于复杂网络，这个代码实现起来异常复杂，而框架恰恰帮我们解决了这个痛点。 实现数据输入我们从最最最简单开始写起，加入我们有一个训练内容。给数据输入1，让他返回2。去找到符合这个的一个模型。那么输入内容就是array([1, 2])。相应的reader实现: 12def reader(data): return enumerate(data) 网络层实现我们假设该网络就是简单的线性拟合y = Wx + B，那么对于网络整体结构，可以如下图表示设计相关代码 123456789101112class Layer(object): def __init__(self): self.w = random.randint(-10, 10) self.g = Noneclass Mul(Layer): def forward(self, x): return self.w * x def backward(self, x, grad): self.g = grad * x 损失函数实现损失函数如图所示就是一个减法误差的平方，我们将他最小化。 123456789class Loss(object): def forward(self, out, label): self.out = out self.label = label return (label - out) ** 2 def backward(self): self.g = 2 * (self.label - self.out) * (-1) 优化器实现优化器使用传统的梯度下降 123456class Opt(object): def __init__(self, lr): self.lr = lr def minimize(self, layer): layer.w = layer.w - layer.g * self.lr 训练效果黄色为收敛cost曲线，蓝色为W值变化曲线 整体代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import randomimport timeimport matplotlib.pyplot as plt# random.seed(33)class Layer(object): def __init__(self): self.w = random.randint(-10, 10) self.g = Noneclass Mul(Layer): def forward(self, x): return self.w * x def backward(self, x, grad): self.g = grad * xclass Loss(object): def forward(self, out, label): self.out = out self.label = label return (label - out) ** 2 def backward(self): self.g = 2 * (self.label - self.out) * (-1)class Opt(object): def __init__(self, lr): self.lr = lr def minimize(self, layer): layer.w = layer.w - layer.g * self.lrdef reader(data): return enumerate(data)def run(): epoch = 200 d = [[1, 2], [2, 4]] model = Mul() loss = Loss() opt = Opt(lr=0.01) print(&quot;[w] init is &#123;&#125;&quot;.format(model.w)) # time.sleep(2) plt.figure() all = [] all_w = [] for i in range(epoch): print(&quot;[Epoch] &#123;&#125;&quot;.format(i, )) for bid, data in reader(d): label = data[1] input = data[0] out = model.forward(input) cost = loss.forward(out, label) print(&quot;[cost] is &#123;&#125;&quot;.format(cost)) loss.backward() model.backward(input, loss.g) opt.minimize(model) print(&quot;[w value] is &#123;&#125;&quot;.format(model.w)) print(&quot;=============================&quot;) all_w.append(model.w) # time.sleep(1) all.append(cost) print(i) plt.plot(all) plt.plot(all_w) plt.show()run()","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.zhengtianyu.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"框架入门","slug":"深度学习/框架入门","permalink":"http://www.zhengtianyu.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"}],"tags":[]},{"title":"md 基本操作","slug":"md-基本操作","date":"2021-08-18T09:39:51.000Z","updated":"2021-08-18T11:56:25.155Z","comments":true,"path":"2021/08/18/md-基本操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/18/md-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"MD基本操作 这篇文章用来测试模板展示效果，以及查找对应的格式写法","text":"MD基本操作 这篇文章用来测试模板展示效果，以及查找对应的格式写法 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题列表无序列表123456789101112//形式一+ a+ b+ c//形式二- d- e- f//形式三* g* h* i //形式一 a b c //形式二 d e f //形式三 g h i 有序列表12345678//正常形式1. abc2. bcd3. cde//错序效果2. fgh3. ghi5. hij //正常形式 abc bcd cde //错序效果 fgh ghi hij 嵌套列表1234567891011121314//无序列表嵌套+ 123 + abc + bcd + cde+ 465+ 789//有序列表嵌套1. abcd 1. abcde 2. abcde 3. abcde2. bcde3. cdef //无序列表嵌套 123 abc bcd cde 465 789 //有序列表嵌套 abcd abcde abcde abcde bcde cdef 引用区块对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。 正常形式1&gt; 引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。 这是一个引用 嵌套区块123456&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用&gt;&gt;&gt;&gt;&gt; 五级引用&gt;&gt;&gt;&gt;&gt;&gt; 六级引用 一级引用 二级引用 三级引用 四级引用 五级引用 六级引用 代码块单行代码1直接用`code`包裹 查询linux文件目录和隐藏文件命令为ls -al 多行代码1使用```包裹 12这里面是多行代码hello world！ 链接行内式链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来 1[百度](https://www.baidu.com &quot;百度主页&quot;) 百度：点击试试 图片图片直接放在生成文件的同名文件夹下，直接引入即可。 12![这是代替图片的文字，随便写](xxxx.jpeg)&lt;img src=mingrixiang.jpeg width=30% /&gt; 分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以 123456789---- - -------**** * *******____ _ _______ 效果都一样 强调字体123456*DDDivano* 倾斜**DDDivano** 加粗_DDDivano_ 倾斜__DDDivano__ 加粗***DDDivano*** 倾斜加粗~~DDDivano~~ 删除 DDDivano 倾斜DDDivano 加粗DDDivano 倾斜DDDivano 加粗DDDivano 倾斜加粗DDDivano 删除 表格123456789101112131415161718//例子一|123|234|345||:-|:-:|-:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|//例子二|123|234|345||:---|:---:|---:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|//例子三123|234|345:-|:-:|-:abc|bcd|cdeabc|bcd|cdeabc|bcd|cde //例子一 123 234 345 abc bcd cde abc bcd cde abc bcd cde //例子二 123 234 345 abc bcd cde abc bcd cde abc bcd cde //例子三 123 234 345 abc bcd cde abc bcd cde abc bcd cde","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"md","slug":"编程技术/md","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/md/"}],"tags":[]},{"title":"git 基本操作","slug":"git-基本操作","date":"2021-08-18T09:16:52.000Z","updated":"2021-08-20T09:41:18.222Z","comments":true,"path":"2021/08/18/git-基本操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/18/git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"git 基本操作 用来记录Git常用命令","text":"git 基本操作 用来记录Git常用命令 git 提交代码三板斧123git addgit commit -m &quot;your comment&quot;git push origin master 这三条命令即可完成90%的日常工作。 git clone代码123git clone https://github.com/WeakAuras/WeakAuras2.git # 克隆wa代码仓库git clone -b bc https://github.com/WeakAuras/WeakAuras2.git # 克隆wa代码仓库bc分支 -b (分支名，指定分支，不指定就是默认分支)git clone https://github.com/WeakAuras/WeakAuras2.git aaa # 克隆wa代码仓库并命名为aaa git 分支管理123456git branch # 查看分支git branch xxx # 创建分支git branch -a # 查看全部分支 包括远程仓库git branch -D xxx # 删除 xxx分支git checkout -b xxx # 创建并checkout 过去git checkout xxx # 切换到xxx分支 git branch 创建一个分支后，该分支起始点即是创建当前所在分支点。创建分支切换，不会更改本地未在git仓库的文件，即未进行git add的文件，所以不用担心会影响本地修改。但是如果checkout的分支与本地目前文件存在冲突，需要手动处理。例如：分支a下，新建文件a，checkout 分支b， 分支b本身存在文件a，那就会报冲突。git merge xxx 用来把xxx分支合并到当前分支。 比如把b分支合并到a分支，需要切换到a分支git checkout a，使用git merge b进行合并。如果有冲突需要手动解决冲突。 git 标签管理12345git tag xxx # 打标签名字为xxxgit tag -d xxx #删除xxx标签git push并不会把tag标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。git push origin v1.0 # 将本地v1.0的tag推送到远端服务器git push [origin] --tags # push 全部tag git tag和git branch区别是，分支是可以进行后续开发，标识一个提交代码全过程的commit，git tag只能标识一个特定的commit，可以理解成commit的友好名字（别名）。 git push提交远程仓库如果你的git代码仓库是从github拉取下来的，默认远程仓库的名字叫origin 12345git push origin xxx # 将xxx分支推送到远程xxx分支git push origin xxx:xxx # 将xxx分支推送到远程xxx分支同理也可以如下操作git push origin xxx:aaa #将xxx分支推送到远程aaa分支，如果能automerge就merge，不能就手动解决。git push origin :aaa # 将空分支推送到远程aaa分支，意思就是把远程aaa分支删了。 git 开源仓库贡献代码这一块相对来说会复杂一些，需要对git有深入的理解。贡献开源代码并不像自己提交远程仓库那样，直接push origin就可以，需要使用pull request的方式，具体原因请自行百度。简要来说，步骤如下： fork开源代码仓库 git clone自己fork的仓库到本地 本地改完了，提交代码到自己fork的仓库 在自己fork的仓库网页处发起pull request到开源仓库 2，3步骤和自己提交远程仓库没有区别。1，4步需要在github的网页用鼠标点击操作，也是没有什么难度。具体难点在于，提交了一个代码后，下一次提交如何基于远程最新的代码进行提交，防止pull request的时候出现冲突。即，同步主仓库最新的代码。 123456git remote add upstream git@github.com:PaddlePaddle/Paddle.git # 把远程仓库加入到本地关联中， 这里upstream可以叫任何名字，等同于origingit fetch upstream # 更新远程仓库git merge upstream/develop # 把远程仓库develop分支 merge到当前分支，保持同步。解决冲突# 或者有另外一种方法git checkout upstream/develop git branch xxxx &amp;&amp; git checkout xxxx # checkout 最新主库分支，并基于主库分支创建一个本地的分支，后续修改直接在xxxx分支上修改 以上就是如何提交pr的基本操作 git 拉取pr1git fetch origin pull/xxxx/head:pr_xxxx # 拉取origin的xxxx（pr号）到本地的pr_xxxx分支 git pull 和 git fetch 区别pull=fetch+merge，pull的话，下拉远程分支并与本地分支合并。fetch只是下拉远程分支，怎么合并，可以自己再做选择。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"git","slug":"编程技术/git","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/git/"}],"tags":[]},{"title":"docker 基本操作","slug":"docker-基本操作","date":"2021-08-18T09:13:16.000Z","updated":"2021-08-18T09:16:27.369Z","comments":true,"path":"2021/08/18/docker-基本操作/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/18/docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"docker","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"docker","slug":"编程技术/docker","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/docker/"}],"tags":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"docker","slug":"docker","permalink":"http://www.zhengtianyu.com/tags/docker/"}]},{"title":"test images","slug":"test-images","date":"2021-08-17T11:01:44.000Z","updated":"2021-08-18T08:46:03.801Z","comments":true,"path":"2021/08/17/test-images/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/17/test-images/","excerpt":"爱仕达大厦爱仕达大厦","text":"爱仕达大厦爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦 爱仕达大厦","categories":[],"tags":[]},{"title":"my first blog","slug":"my-first-blog","date":"2021-08-17T10:22:25.000Z","updated":"2021-08-17T10:23:24.506Z","comments":true,"path":"2021/08/17/my-first-blog/","link":"","permalink":"http://www.zhengtianyu.com/2021/08/17/my-first-blog/","excerpt":"","text":"Hello World!这应该是一个美好的开始！","categories":[],"tags":[{"name":"世界","slug":"世界","permalink":"http://www.zhengtianyu.com/tags/%E4%B8%96%E7%95%8C/"}]}],"categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"python","slug":"编程技术/python","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/python/"},{"name":"游戏人生","slug":"游戏人生","permalink":"http://www.zhengtianyu.com/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"},{"name":"阴阳师","slug":"游戏人生/阴阳师","permalink":"http://www.zhengtianyu.com/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/%E9%98%B4%E9%98%B3%E5%B8%88/"},{"name":"深度学习","slug":"深度学习","permalink":"http://www.zhengtianyu.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"框架入门","slug":"深度学习/框架入门","permalink":"http://www.zhengtianyu.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"name":"md","slug":"编程技术/md","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/md/"},{"name":"git","slug":"编程技术/git","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/git/"},{"name":"docker","slug":"编程技术/docker","permalink":"http://www.zhengtianyu.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/docker/"}],"tags":[{"name":"界面辅助","slug":"界面辅助","permalink":"http://www.zhengtianyu.com/tags/%E7%95%8C%E9%9D%A2%E8%BE%85%E5%8A%A9/"},{"name":"自动化","slug":"自动化","permalink":"http://www.zhengtianyu.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"pyautogui","slug":"pyautogui","permalink":"http://www.zhengtianyu.com/tags/pyautogui/"},{"name":"编程技术","slug":"编程技术","permalink":"http://www.zhengtianyu.com/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"docker","slug":"docker","permalink":"http://www.zhengtianyu.com/tags/docker/"},{"name":"世界","slug":"世界","permalink":"http://www.zhengtianyu.com/tags/%E4%B8%96%E7%95%8C/"}]}